diff --git a/dist/trescientos.js b/dist/trescientos.js
index 4cbd27f2fc549510256a976961b8422cdb23c415..22b677223b4b42d0ad7e93897f0210258b3d9422 100644
--- a/dist/trescientos.js
+++ b/dist/trescientos.js
@@ -17743,10 +17743,10 @@ const om = ["args"], rm = ["color"], Sv = /* @__PURE__ */ ue({
       instance: h
     });
     const g = [a].map((w, E) => ({
-      x: i.value / 2 - Math.random() * i.value,
-      y: i.value / 2 - Math.random() * i.value,
-      scale: 0.4 + Math.sin((E + 1) / a.value * Math.PI) * ((0.2 + Math.random()) * 10),
-      density: Math.max(0.2, Math.random()),
+      x: i.value / 2 - 0.7 * i.value,
+      y: i.value / 2 - 1 * i.value,
+      scale: 0.4 + Math.sin((E + 1) / a.value * Math.PI) * 4,
+      density: 0.35 + (E / 7),
       rotation: Math.max(2e-3, 5e-3 * Math.random()) * d.value
     })), v = (w, E) => w / 6 * E * u.value, { map: p } = ([t, n] = Tn(() => Bn({ map: l.value })), t = await t, n(), t), { renderer: b, camera: _ } = xe(), M = Pe(() => {
       var w;
diff --git a/dist/trescientos.umd.cjs b/dist/trescientos.umd.cjs
index 5aef9285551d5707dbc5e41c639a40c758a9fbbe..4f63acfb9f1a936820e4dcf1561036ee33b6ca37 100644
--- a/dist/trescientos.umd.cjs
+++ b/dist/trescientos.umd.cjs
@@ -1543,7 +1543,7 @@ void main() {
       #include <tonemapping_fragment>
       #include <colorspace_fragment>
     }
-  `);H.extend({GridMaterial:t});const n=u.shallowRef(new l.Mesh),o=new l.Plane,r=new l.Vector3(0,1,0),s=new l.Vector3(0,0,0);return H.useLoop().onBeforeRender(a=>{o.setFromNormalAndCoplanarPoint(r,s).applyMatrix4(n.value.matrixWorld);const c=n.value.material,h=c.uniforms.worldCamProjPosition,p=c.uniforms.worldPlanePosition;o.projectPoint(a.camera.position,h.value),p.value.set(0,0,0).applyMatrix4(n.value.matrixWorld)}),(a,c)=>(u.openBlock(),u.createElementBlock("TresMesh",{ref_key:"ref",ref:n,"frustum-culled":!1},[u.createElementVNode("TresGridMaterial",{transparent:!0,"extensions-derivatives":!0,side:e.side,"cell-size":e.cellSize,"section-size":e.sectionSize,"cell-color":e.cellColor,"section-color":e.sectionColor,"cell-thickness":e.cellThickness,"section-thickness":e.sectionThickness,"fade-distance":e.fadeDistance,"fade-strength":e.fadeStrength,"fade-from":e.fadeFrom,"infinite-grid":e.infiniteGrid,"follow-camera":e.followCamera},null,8,Pd),u.createElementVNode("TresPlaneGeometry",{args:e.args},null,8,Cd)],512))}}),Id=["rotation-x","args"],Od=u.defineComponent({__name:"Ocean",props:{textureWidth:{default:512},textureHeight:{default:512},waterNormals:{default:"https://raw.githubusercontent.com/Tresjs/assets/main/textures/water-normals/Water_1_M_Normal.jpg"},sunDirection:{default:()=>new l.Vector3},sunColor:{default:16777215},waterColor:{default:7695},distortionScale:{default:3.7},size:{default:1},clipBias:{default:0},alpha:{default:1},side:{default:l.FrontSide}},async setup(i,{expose:e}){let t,n;const o=i,{textureWidth:r,textureHeight:s,waterNormals:a,sunDirection:c,sunColor:h,waterColor:p,distortionScale:f,size:m,clipBias:d,alpha:y,side:_}=u.toRefs(o),{extend:v,scene:g}=H.useTresContext();v({Water:Wa});const A=u.shallowRef(),w=u.shallowRef(),C=g.value.fog!==void 0;e({instance:A}),g.value.traverse(P=>{Object.prototype.hasOwnProperty.call(P,"isSky")&&(w.value=P)}),u.onMounted(async()=>{if(await u.nextTick(),w.value){const P=w.value.material.uniforms.sunPosition.value;A.value.material.uniforms.sunDirection.value.copy(P)}});const{normalMap:L}=([t,n]=u.withAsyncContext(()=>H.useTexture({normalMap:a.value})),t=await t,n(),t);L.wrapS=L.wrapT=l.RepeatWrapping;const{onBeforeRender:M}=H.useLoop();return M(({delta:P,invalidate:b})=>{A.value.material.uniforms.time.value+=P,b()}),(P,b)=>(u.openBlock(),u.createElementBlock("TresWater",{ref_key:"waterRef",ref:A,"rotation-x":-Math.PI/2,args:[void 0,{textureWidth:u.unref(r),textureHeight:u.unref(s),waterNormals:u.unref(L),sunDirection:u.unref(c),sunColor:u.unref(h),waterColor:u.unref(p),distortionScale:u.unref(f),fog:C,size:u.unref(m),clipBias:u.unref(d),alpha:u.unref(y),side:u.unref(_)}]},[u.renderSlot(P.$slots,"default",{},()=>[b[0]||(b[0]=u.createElementVNode("TresPlaneGeometry",{args:[1e4,1e4]},null,-1))])],8,Id))}}),Ld=["size","color","alpha-map","map","opacity","alpha-test","depth-write","transparent","size-attenuation"],Dd=["position","velocity"],kd=u.defineComponent({__name:"Precipitation",props:{size:{default:.1},area:{default:()=>[10,10,20]},color:{default:16777215},map:{},alphaMap:{},alphaTest:{default:.01},opacity:{default:.8},count:{default:5e3},speed:{default:.1},randomness:{default:.5},depthWrite:{type:Boolean,default:!1},transparent:{type:Boolean,default:!0},sizeAttenuation:{type:Boolean,default:!0}},setup(i,{expose:e}){const t=i,{size:n,area:o,color:r,alphaMap:s,map:a,opacity:c,alphaTest:h,depthWrite:p,transparent:f,sizeAttenuation:m,count:d,speed:y,randomness:_}=u.toRefs(t),v=u.shallowRef();let g=[],A=[];const w=()=>{g=new Float32Array(d.value*3);for(let S=0;S<d.value;S++){const x=S*3;g[x]=(Math.random()-.5)*o.value[0],g[x+1]=(Math.random()-.5)*o.value[1],g[x+2]=(Math.random()-.5)*o.value[2]}},C=()=>{A=new Float32Array(d.value*2);for(let S=0;S<d.value*2;S+=2)A[S]=(Math.random()-.5)/5*y.value*_.value,A[S+1]=Math.random()/5*y.value};C(),w(),u.watchEffect(()=>{C(),w()});const L=u.shallowRef(null),M=u.shallowRef(null);u.watchEffect(async()=>{u.watchEffect(async()=>{if(typeof s.value=="string"){const S=await H.useTexture({alphaMap:s.value});L.value=S.alphaMap}else L.value=s.value??null;if(typeof a.value=="string"){const S=await H.useTexture({map:a.value});M.value=S.map}else M.value=a.value??null})});const{onBeforeRender:P}=H.useLoop();P(({invalidate:S})=>{var x,I;if((x=v.value)!=null&&x.attributes.position.array&&((I=v.value)!=null&&I.attributes.position.count)){const D=v.value.attributes.position.array;for(let z=0;z<v.value.attributes.position.count;z++){const G=A[z*2],E=A[z*2+1];D[z*3]+=G,D[z*3+1]-=E,(D[z*3]<=-o.value[0]/2||D[z*3]>=o.value[0]/2)&&(D[z*3]=D[z*3]*-1),(D[z*3+1]<=-o.value[1]/2||D[z*3+1]>=o.value[1]/2)&&(D[z*3+1]=D[z*3+1]*-1)}v.value.attributes.position.needsUpdate=!0,S()}});const b=u.shallowRef();return e({instance:b}),(S,x)=>(u.openBlock(),u.createElementBlock("TresPoints",{ref_key:"pointsRef",ref:b},[u.createElementVNode("TresPointsMaterial",{size:u.unref(n),color:u.unref(r),"alpha-map":L.value,map:M.value,opacity:u.unref(c),"alpha-test":u.unref(h),"depth-write":u.unref(p),transparent:u.unref(f),"size-attenuation":u.unref(m)},null,8,Ld),u.createElementVNode("TresBufferGeometry",{ref_key:"geometryRef",ref:v,position:[u.unref(g),3],velocity:[u.unref(A)]},null,8,Dd)],512))}}),Bd=["object","material-uniforms-turbidity-value","material-uniforms-rayleigh-value","material-uniforms-mieCoefficient-value","material-uniforms-mieDirectionalG-value","material-uniforms-sunPosition-value","scale"],Ud=u.defineComponent({__name:"Sky",props:{turbidity:{default:3.4},rayleigh:{default:3},mieCoefficient:{default:.005},mieDirectionalG:{default:.7},elevation:{default:.6},azimuth:{default:180},distance:{default:45e4}},setup(i,{expose:e}){const t=i,{invalidate:n}=H.useTresContext();u.watch(t,()=>n());const o=u.shallowRef(),r=new Hn,s=u.computed(()=>a(t.azimuth,t.elevation));function a(c,h){const p=l.MathUtils.degToRad(90-h),f=l.MathUtils.degToRad(c);return new l.Vector3().setFromSphericalCoords(1,p,f)}return e({instance:o,sunPosition:s.value}),(c,h)=>(u.openBlock(),u.createElementBlock("primitive",{ref_key:"skyRef",ref:o,object:u.unref(r),"material-uniforms-turbidity-value":t.turbidity,"material-uniforms-rayleigh-value":t.rayleigh,"material-uniforms-mieCoefficient-value":t.mieCoefficient,"material-uniforms-mieDirectionalG-value":t.mieDirectionalG,"material-uniforms-sunPosition-value":s.value,scale:t.distance},null,8,Bd))}}),Nd=["position"],Fd=["position"],zd=["scale"],Vd=["map","depth-test","color-space","color","opacity"],Gd=u.defineComponent({__name:"Smoke",props:{color:{default:"#ffffff"},opacity:{default:.5},speed:{default:.4},width:{default:10},depth:{default:1.5},segments:{default:20},texture:{default:"https://raw.githubusercontent.com/Tresjs/assets/main/textures/clouds/defaultCloud.png"},depthTest:{type:Boolean,default:!0}},async setup(i,{expose:e}){let t,n;const o=i,{width:r,depth:s,segments:a,texture:c,color:h,depthTest:p,opacity:f,speed:m}=u.toRefs(o),d=u.shallowRef(),y=u.shallowRef();e({instance:d});const _=[a].map((M,P)=>({x:r.value/2-Math.random()*r.value,y:r.value/2-Math.random()*r.value,scale:.4+Math.sin((P+1)/a.value*Math.PI)*((.2+Math.random())*10),density:Math.max(.2,Math.random()),rotation:Math.max(.002,.005*Math.random())*m.value})),v=(M,P)=>M/6*P*f.value,{map:g}=([t,n]=u.withAsyncContext(()=>H.useTexture({map:c.value})),t=await t,n(),t),{renderer:A,camera:w}=H.useTresContext(),C=u.computed(()=>{var M;return(M=A.value)==null?void 0:M.outputColorSpace}),{onBeforeRender:L}=H.useLoop();return L(({invalidate:M})=>{var P,b;d.value&&w.value&&y.value&&((P=y.value)==null||P.children.forEach((S,x)=>{S.rotation.z+=_[x].rotation}),d.value.lookAt((b=w.value)==null?void 0:b.position),M())}),(M,P)=>(u.openBlock(),u.createElementBlock("TresGroup",u.mergeProps({ref_key:"smokeRef",ref:d},M.$attrs),[u.createElementVNode("TresGroup",{ref_key:"groupRef",ref:y,position:[0,0,u.unref(a)/2*u.unref(s)]},[(u.openBlock(!0),u.createElementBlock(u.Fragment,null,u.renderList(u.unref(_),({scale:b,x:S,y:x,density:I},D)=>(u.openBlock(),u.createElementBlock("TresMesh",{key:`${D}`,position:[S,x,-D*u.unref(s)]},[u.createElementVNode("TresPlaneGeometry",{scale:[b,b,b],rotation:[0,0,0]},null,8,zd),u.createElementVNode("TresMeshStandardMaterial",{map:u.unref(g),"depth-test":u.unref(p),"color-space":C.value,color:u.unref(h),"depth-write":!1,transparent:"",opacity:v(b,I)},null,8,Vd)],8,Fd))),128))],8,Nd)],16))}}),Rd=`
+  `);H.extend({GridMaterial:t});const n=u.shallowRef(new l.Mesh),o=new l.Plane,r=new l.Vector3(0,1,0),s=new l.Vector3(0,0,0);return H.useLoop().onBeforeRender(a=>{o.setFromNormalAndCoplanarPoint(r,s).applyMatrix4(n.value.matrixWorld);const c=n.value.material,h=c.uniforms.worldCamProjPosition,p=c.uniforms.worldPlanePosition;o.projectPoint(a.camera.position,h.value),p.value.set(0,0,0).applyMatrix4(n.value.matrixWorld)}),(a,c)=>(u.openBlock(),u.createElementBlock("TresMesh",{ref_key:"ref",ref:n,"frustum-culled":!1},[u.createElementVNode("TresGridMaterial",{transparent:!0,"extensions-derivatives":!0,side:e.side,"cell-size":e.cellSize,"section-size":e.sectionSize,"cell-color":e.cellColor,"section-color":e.sectionColor,"cell-thickness":e.cellThickness,"section-thickness":e.sectionThickness,"fade-distance":e.fadeDistance,"fade-strength":e.fadeStrength,"fade-from":e.fadeFrom,"infinite-grid":e.infiniteGrid,"follow-camera":e.followCamera},null,8,Pd),u.createElementVNode("TresPlaneGeometry",{args:e.args},null,8,Cd)],512))}}),Id=["rotation-x","args"],Od=u.defineComponent({__name:"Ocean",props:{textureWidth:{default:512},textureHeight:{default:512},waterNormals:{default:"https://raw.githubusercontent.com/Tresjs/assets/main/textures/water-normals/Water_1_M_Normal.jpg"},sunDirection:{default:()=>new l.Vector3},sunColor:{default:16777215},waterColor:{default:7695},distortionScale:{default:3.7},size:{default:1},clipBias:{default:0},alpha:{default:1},side:{default:l.FrontSide}},async setup(i,{expose:e}){let t,n;const o=i,{textureWidth:r,textureHeight:s,waterNormals:a,sunDirection:c,sunColor:h,waterColor:p,distortionScale:f,size:m,clipBias:d,alpha:y,side:_}=u.toRefs(o),{extend:v,scene:g}=H.useTresContext();v({Water:Wa});const A=u.shallowRef(),w=u.shallowRef(),C=g.value.fog!==void 0;e({instance:A}),g.value.traverse(P=>{Object.prototype.hasOwnProperty.call(P,"isSky")&&(w.value=P)}),u.onMounted(async()=>{if(await u.nextTick(),w.value){const P=w.value.material.uniforms.sunPosition.value;A.value.material.uniforms.sunDirection.value.copy(P)}});const{normalMap:L}=([t,n]=u.withAsyncContext(()=>H.useTexture({normalMap:a.value})),t=await t,n(),t);L.wrapS=L.wrapT=l.RepeatWrapping;const{onBeforeRender:M}=H.useLoop();return M(({delta:P,invalidate:b})=>{A.value.material.uniforms.time.value+=P,b()}),(P,b)=>(u.openBlock(),u.createElementBlock("TresWater",{ref_key:"waterRef",ref:A,"rotation-x":-Math.PI/2,args:[void 0,{textureWidth:u.unref(r),textureHeight:u.unref(s),waterNormals:u.unref(L),sunDirection:u.unref(c),sunColor:u.unref(h),waterColor:u.unref(p),distortionScale:u.unref(f),fog:C,size:u.unref(m),clipBias:u.unref(d),alpha:u.unref(y),side:u.unref(_)}]},[u.renderSlot(P.$slots,"default",{},()=>[b[0]||(b[0]=u.createElementVNode("TresPlaneGeometry",{args:[1e4,1e4]},null,-1))])],8,Id))}}),Ld=["size","color","alpha-map","map","opacity","alpha-test","depth-write","transparent","size-attenuation"],Dd=["position","velocity"],kd=u.defineComponent({__name:"Precipitation",props:{size:{default:.1},area:{default:()=>[10,10,20]},color:{default:16777215},map:{},alphaMap:{},alphaTest:{default:.01},opacity:{default:.8},count:{default:5e3},speed:{default:.1},randomness:{default:.5},depthWrite:{type:Boolean,default:!1},transparent:{type:Boolean,default:!0},sizeAttenuation:{type:Boolean,default:!0}},setup(i,{expose:e}){const t=i,{size:n,area:o,color:r,alphaMap:s,map:a,opacity:c,alphaTest:h,depthWrite:p,transparent:f,sizeAttenuation:m,count:d,speed:y,randomness:_}=u.toRefs(t),v=u.shallowRef();let g=[],A=[];const w=()=>{g=new Float32Array(d.value*3);for(let S=0;S<d.value;S++){const x=S*3;g[x]=(Math.random()-.5)*o.value[0],g[x+1]=(Math.random()-.5)*o.value[1],g[x+2]=(Math.random()-.5)*o.value[2]}},C=()=>{A=new Float32Array(d.value*2);for(let S=0;S<d.value*2;S+=2)A[S]=(Math.random()-.5)/5*y.value*_.value,A[S+1]=Math.random()/5*y.value};C(),w(),u.watchEffect(()=>{C(),w()});const L=u.shallowRef(null),M=u.shallowRef(null);u.watchEffect(async()=>{u.watchEffect(async()=>{if(typeof s.value=="string"){const S=await H.useTexture({alphaMap:s.value});L.value=S.alphaMap}else L.value=s.value??null;if(typeof a.value=="string"){const S=await H.useTexture({map:a.value});M.value=S.map}else M.value=a.value??null})});const{onBeforeRender:P}=H.useLoop();P(({invalidate:S})=>{var x,I;if((x=v.value)!=null&&x.attributes.position.array&&((I=v.value)!=null&&I.attributes.position.count)){const D=v.value.attributes.position.array;for(let z=0;z<v.value.attributes.position.count;z++){const G=A[z*2],E=A[z*2+1];D[z*3]+=G,D[z*3+1]-=E,(D[z*3]<=-o.value[0]/2||D[z*3]>=o.value[0]/2)&&(D[z*3]=D[z*3]*-1),(D[z*3+1]<=-o.value[1]/2||D[z*3+1]>=o.value[1]/2)&&(D[z*3+1]=D[z*3+1]*-1)}v.value.attributes.position.needsUpdate=!0,S()}});const b=u.shallowRef();return e({instance:b}),(S,x)=>(u.openBlock(),u.createElementBlock("TresPoints",{ref_key:"pointsRef",ref:b},[u.createElementVNode("TresPointsMaterial",{size:u.unref(n),color:u.unref(r),"alpha-map":L.value,map:M.value,opacity:u.unref(c),"alpha-test":u.unref(h),"depth-write":u.unref(p),transparent:u.unref(f),"size-attenuation":u.unref(m)},null,8,Ld),u.createElementVNode("TresBufferGeometry",{ref_key:"geometryRef",ref:v,position:[u.unref(g),3],velocity:[u.unref(A)]},null,8,Dd)],512))}}),Bd=["object","material-uniforms-turbidity-value","material-uniforms-rayleigh-value","material-uniforms-mieCoefficient-value","material-uniforms-mieDirectionalG-value","material-uniforms-sunPosition-value","scale"],Ud=u.defineComponent({__name:"Sky",props:{turbidity:{default:3.4},rayleigh:{default:3},mieCoefficient:{default:.005},mieDirectionalG:{default:.7},elevation:{default:.6},azimuth:{default:180},distance:{default:45e4}},setup(i,{expose:e}){const t=i,{invalidate:n}=H.useTresContext();u.watch(t,()=>n());const o=u.shallowRef(),r=new Hn,s=u.computed(()=>a(t.azimuth,t.elevation));function a(c,h){const p=l.MathUtils.degToRad(90-h),f=l.MathUtils.degToRad(c);return new l.Vector3().setFromSphericalCoords(1,p,f)}return e({instance:o,sunPosition:s.value}),(c,h)=>(u.openBlock(),u.createElementBlock("primitive",{ref_key:"skyRef",ref:o,object:u.unref(r),"material-uniforms-turbidity-value":t.turbidity,"material-uniforms-rayleigh-value":t.rayleigh,"material-uniforms-mieCoefficient-value":t.mieCoefficient,"material-uniforms-mieDirectionalG-value":t.mieDirectionalG,"material-uniforms-sunPosition-value":s.value,scale:t.distance},null,8,Bd))}}),Nd=["position"],Fd=["position"],zd=["scale"],Vd=["map","depth-test","color-space","color","opacity"],Gd=u.defineComponent({__name:"Smoke",props:{color:{default:"#ffffff"},opacity:{default:.5},speed:{default:.4},width:{default:10},depth:{default:1.5},segments:{default:20},texture:{default:"https://raw.githubusercontent.com/Tresjs/assets/main/textures/clouds/defaultCloud.png"},depthTest:{type:Boolean,default:!0}},async setup(i,{expose:e}){let t,n;const o=i,{width:r,depth:s,segments:a,texture:c,color:h,depthTest:p,opacity:f,speed:m}=u.toRefs(o),d=u.shallowRef(),y=u.shallowRef();e({instance:d});const _=[a].map((M,P)=>({x:r.value/2-.7*r.value,y:r.value/2-1*r.value,scale:.4+Math.sin((P+1)/a.value*Math.PI)*4,density:.35+(P/7),rotation:Math.max(.002,.005*Math.random())*m.value})),v=(M,P)=>M/6*P*f.value,{map:g}=([t,n]=u.withAsyncContext(()=>H.useTexture({map:c.value})),t=await t,n(),t),{renderer:A,camera:w}=H.useTresContext(),C=u.computed(()=>{var M;return(M=A.value)==null?void 0:M.outputColorSpace}),{onBeforeRender:L}=H.useLoop();return L(({invalidate:M})=>{var P,b;d.value&&w.value&&y.value&&((P=y.value)==null||P.children.forEach((S,x)=>{S.rotation.z+=_[x].rotation}),d.value.lookAt((b=w.value)==null?void 0:b.position),M())}),(M,P)=>(u.openBlock(),u.createElementBlock("TresGroup",u.mergeProps({ref_key:"smokeRef",ref:d},M.$attrs),[u.createElementVNode("TresGroup",{ref_key:"groupRef",ref:y,position:[0,0,u.unref(a)/2*u.unref(s)]},[(u.openBlock(!0),u.createElementBlock(u.Fragment,null,u.renderList(u.unref(_),({scale:b,x:S,y:x,density:I},D)=>(u.openBlock(),u.createElementBlock("TresMesh",{key:`${D}`,position:[S,x,-D*u.unref(s)]},[u.createElementVNode("TresPlaneGeometry",{scale:[b,b,b],rotation:[0,0,0]},null,8,zd),u.createElementVNode("TresMeshStandardMaterial",{map:u.unref(g),"depth-test":u.unref(p),"color-space":C.value,color:u.unref(h),"depth-write":!1,transparent:"",opacity:v(b,I)},null,8,Vd)],8,Fd))),128))],8,Nd)],16))}}),Rd=`
 return PCSS( shadowMap, shadowCoord );
 `,jd=u.defineComponent({__name:"SoftShadows",props:{size:{default:25},samples:{default:10},focus:{default:0}},setup(i){const e=i,t=({focus:h=0,size:p=25,samples:f=10}={})=>`
 #define PENUMBRA_FILTER_SIZE float(${p})
